     1: #include "delay.h"
     2: #include "device.h"
     3: #include "lcd44780.h"
     4: 
     5: #ifdef USE_HD44780_LCD
     6: 
     7: #include <stdarg.h>
     8: #include <stdio.h>
     9: 
    10: #if defined(DATA4_PIN) && defined(DATA5_PIN) && defined(DATA6_PIN) && defined(DATA7_PIN) && defined(DATA4_TRIS) &&     \
    11:     defined(DATA5_TRIS) && defined(DATA6_TRIS) && defined(DATA7_TRIS)
    12: #define LCD_HAVE_8BIT_MODE 1
    13: #endif
    14: 
    15: static uint8_t LCD_function, LCD_ctrl, LCD_mode
    16: #ifdef LCDSETCURSOR
    17:     ,
    18:     LCD_lines
    19: #endif
    20:     ;
    21: 
    22: /** Positive pulse on E */
    23: // enable pulse must be >450ns
    24: // commands need > 37us to settle
    25: #define lcd_pulse_enable()                                                                                             \
    26:   EN_HIGH();                                                                                                           \
    27:   delay_us(4);                                                                                                         \
    28:   EN_LOW();                                                                                                            \
    29:   delay_us(100);
    30: 
    31: // -------------------------------------------------------------------------
    32: /** Write using 4bits mode */
    33: static void
    34: lcd_write4bits(uint8_t value) {
    35: #if DATABUS_MUX
    36:   DATA0_TRIS = DATA1_TRIS = DATA2_TRIS = DATA3_TRIS = OUTPUT;
    37: #endif
    38: 
    39:   OUTB &= 0b00001111;
    40:   OUTB |= value << 4;
    41:   /*
    42:     DATA0_PIN = value & 1;
    43:     value >>= 1;
    44:     DATA1_PIN = value & 1;
    45:     value >>= 1;
    46:     DATA2_PIN = value & 1;
    47:     value >>= 1;
    48:     DATA3_PIN = value & 1;
    49:     */
    50: 
    51: #if DATABUS_MUX
    52: //  delay_us(DATABUS_MUXDELAY);
    53: #endif
    54: 
    55:   lcd_pulse_enable();
    56: 
    57: #if DATABUS_MUX
    58:   DATA0_TRIS = DATA1_TRIS = DATA2_TRIS = DATA3_TRIS = INPUT;
    59: #endif
    60: }
    61: 
    62: // -------------------------------------------------------------------------
    63: #ifdef LCD_HAVE_8BIT_MODE
    64: /** Write using 8bits mode */
    65: static void
    66: lcd_write8bits(uint8_t value) {
    67: 
    68: #if DATABUS_MUX
    69:   DATA0_TRIS = DATA1_TRIS = DATA2_TRIS = DATA3_TRIS = DATA4_TRIS = DATA5_TRIS = DATA6_TRIS = DATA7_TRIS = OUTPUT;
    70: #endif
    71: 
    72:   DATA0_PIN = value & 1;
    73:   value >>= 1;
    74:   DATA1_PIN = value & 1;
    75:   value >>= 1;
    76:   DATA2_PIN = value & 1;
    77:   value >>= 1;
    78:   DATA3_PIN = value & 1;
    79:   value >>= 1;
    80:   DATA4_PIN = value & 1;
    81:   value >>= 1;
    82:   DATA5_PIN = value & 1;
    83:   value >>= 1;
    84:   DATA6_PIN = value & 1;
    85:   value >>= 1;
    86:   DATA7_PIN = value & 1;
    87: 
    88: #if DATABUS_MUX
    89: //  delay_us(DATABUS_MUXDELAY);
    90: #endif
    91: 
    92:   lcd_pulse_enable();
    93: 
    94: #if DATABUS_MUX
    95:   DATA0_TRIS = DATA1_TRIS = DATA2_TRIS = DATA3_TRIS = DATA4_TRIS = DATA5_TRIS = DATA6_TRIS = DATA7_TRIS = INPUT;
    96: #endif
    97: }
    98: #endif
    99: 
   100: // -------------------------------------------------------------------------
   101: /** Send data to LCD 8 or 4 bits */
   102: void
   103: lcd_send(uint8_t value, uint8_t mode) {
   104:   if(mode) {
   105:     RS_HIGH();
   106:   } else {
   107:     RS_LOW();
   108:   }
   109: 
   110: #ifdef LCD_HAVE_8BIT_MODE
   111:   if(LCD_function & LCD_8BITMODE) {
   112:     lcd_write8bits(value);
   113:   } else
   114: #endif
   115:   {
   116:     lcd_write4bits(value >> 4); // Upper 4 bits first
   117:     lcd_write4bits(value);      // Lower 4 bits second
   118:   }
   119: }
   120: 
   121: // -------------------------------------------------------------------------
   122: /** Write a data character on LCD */
   123: 
   124: // -------------------------------------------------------------------------
   125: /** Write a control command on LCD */
   126: static void
   127: lcd_command(uint8_t value) {
   128:   lcd_send(value, LOW);
   129: }
   130: 
   131: // -------------------------------------------------------------------------
   132: /** Setup line x column on LCD */
   133: #ifdef LCDSETCURSOR
   134: void
   135: lcd_gotoxy(uint8_t col, uint8_t row) {
   136:   //  uint8_t row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
   137:   uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
   138: 
   139:   //  row %= LCD_lines;
   140:   /* Added 26 May 2012 by MFH
   141:     sets row_offsets for a single line display so that
   142:     80 column space divided in 4 equal 20 column sections.
   143:     This means that if an n x 4 display is set to behave as
   144:     a single line display lines 1 and 2 are displayed and
   145:     lines 3 and 4 are 20 characters to the right.*/
   146:   if(LCD_lines == 1) {
   147:     row_offsets[1] = 0x14;
   148:     row_offsets[2] = 0x28;
   149:     row_offsets[3] = 0x3C;
   150:   }
   151:   /* Removed 26 May 2012 by MFH as did not treat row
   152:     starts consistently for n x 2 and n x 4 displays
   153:   if(row > LCD_lines)
   154:     row = LCD_lines-1;    // we count rows starting w/0
   155:   */
   156:   lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
   157: }
   158: #endif
   159: 
   160: /** Print a string on LCD */
   161: #if 1 // def LCDPRINT
   162: void
   163: lcd_puts(const char* string) {
   164:   uint8_t i;
   165:   for(i = 0; string[i]; i++) lcd_putch(string[i]);
   166: }
   167: #endif
   168: 
   169: // -------------------------------------------------------------------------
   170: /** Write formated string on LCD **/
   171: #ifdef LCDPRINTF
   172: /* added 28/01/2011 rblanchot@gmail.com */
   173: void
   174: lcd_printf(const char* fmt, ...) {
   175:   va_list args;
   176: 
   177:   va_start(args, fmt);
   178:   pprintf(lcd_putch, fmt, args);
   179:   va_end(args);
   180: }
   181: #endif
   182: 
   183: /** Print a number on LCD */
   184: #if defined(LCDPRINTNUMBER) || defined(LCDPRINTFLOAT)
   185: /*
   186: static const char digits[] =
   187: {
   188: '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
   189: };
   190: */
   191: void
   192: lcd_print_number(uint16_t n, uint8_t base, int8_t pad /*, int8_t pointpos*/) {
   193:   uint8_t buf[8 * sizeof(long)]; // Assumes 8-bit chars.
   194:   uint8_t di;
   195:   int8_t i = 0;
   196:   char padchar = ' ';
   197: 
   198:   if(pad < 0) {
   199:     pad = -pad;
   200:     padchar = '0';
   201:   }
   202: 
   203:   /*  if(n == 0) {
   204:       lcd_putch('0');
   205:       return;
   206:     }*/
   207: 
   208:   do {
   209:     /*    if(i == pointpos)
   210:           buf[i++] = '.';
   211:     */
   212:     di = n % base;
   213:     buf[i++] = (di < 10 ? (uint8_t)'0' + di : (uint8_t)'A' + di - 10);
   214: 
   215:     n /= base;
   216:   } while(n > 0);
   217: 
   218:   while(pad-- >= i) lcd_putch(padchar);
   219: 
   220:   for(; i > 0; i--) lcd_putch((char)buf[(int16_t)i - 1]);
   221:   //    lcd_putch((buf[i - 1] < 10 ? (char)'0' + buf[i - 1] : (char)'A' + buf[i - 1] - 10));
   222: }
   223: 
   224: #endif
   225: 
   226: /** Print a float number to LCD */
   227: #ifdef LCDPRINTFLOAT
   228: void
   229: lcd_print_float(float number, uint8_t digits) {
   230: 
   231:   char buf[16];
   232:   sprintf(buf, "%f", number);
   233:   lcd_puts(buf);
   234:   //  lcd_print_number_internal((long)(number * 1000), 10, 1);
   235: 
   236:   // uint8_t i, toPrint;
   237:   // uint16_t int_part;
   238:   // float rounding, remainder;
   239: 
   240:   ///* Handle negative numbers */
   241:   // if(number < 0.0) {
   242:   //  lcd_putch('-');
   243:   //  number = -number;
   244:   //}
   245: 
   246:   ///* Round correctly so that print(1.999, 2) prints as "2.00" */
   247:   // rounding = 0.5;
   248:   // for(i=0; i<digits; ++i)
   249:   //  rounding /= 10.0;
   250: 
   251:   // number += rounding;
   252: 
   253:   ///* Extract the integer part of the number and print it */
   254:   // int_part = (uint16_t)number;
   255:   // remainder = number - (float)int_part;
   256:   // lcd_print_number(int_part, 10);
   257: 
   258:   ///* Print the decimal point, but only if there are digits beyond */
   259:   // if(digits > 0)
   260:   //  lcd_putch('.');
   261: 
   262:   ///* Extract digits from the remainder one at a time */
   263:   // while(digits-- > 0) {
   264:   //  remainder *= 10.0;
   265:   //  toPrint = (uint16_t)remainder; //Integer part without use of math.h lib, I think better! (Fazzi)
   266:   //  lcd_print_number(toPrint, 10);
   267:   //  remainder -= toPrint;
   268:   //}
   269: }
   270: #endif
   271: 
   272: // -------------------------------------------------------------------------
   273: /** Move cursor to Home position */
   274: #ifdef LCDHOME
   275: void
   276: lcd_home() {
   277:   lcd_command(LCD_RETURNHOME);
   278:   delay_ms(2); // Wait for more than 4.1 ms
   279:   // delay_us(2000);
   280: }
   281: #endif
   282: 
   283: // -------------------------------------------------------------------------
   284: /** Clear LCD */
   285: #ifdef LCDCLEAR
   286: void
   287: lcd_clear() {
   288:   lcd_command(LCD_CLEARDISPLAY); // clear display, set cursor position to zero
   289:   delay_ms(2);                   // Wait for more than 4.1 ms
   290:   // delay_us(2000);  // this command takes a long time! */
   291: }
   292: #endif
   293: 
   294: // -------------------------------------------------------------------------
   295: /** Turn the display on/off (quickly) */
   296: #ifndef LCDDISPLAY
   297: void
   298: lcd_no_display() {
   299:   LCD_ctrl &= ~LCD_DISPLAYON;
   300:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   301: }
   302: #endif
   303: 
   304: // -------------------------------------------------------------------------
   305: #ifdef LCDDISPLAY
   306: void
   307: lcd_display() {
   308:   LCD_ctrl |= LCD_DISPLAYON;
   309:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   310: }
   311: #endif
   312: 
   313: // -------------------------------------------------------------------------
   314: /** Turns the underline cursor on/off */
   315: #ifdef LCDCURSOR
   316: void
   317: lcd_no_cursor() {
   318:   LCD_ctrl &= ~LCD_CURSORON;
   319:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   320: }
   321: #endif
   322: 
   323: // -------------------------------------------------------------------------
   324: #ifdef LCDCURSOR
   325: void
   326: lcd_cursor() {
   327:   LCD_ctrl |= LCD_CURSORON;
   328:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   329: }
   330: #endif
   331: 
   332: // -------------------------------------------------------------------------
   333: /** Turn on and off the blinking cursor */
   334: #ifndef LCDBLINK
   335: void
   336: lcd_no_blink() {
   337:   LCD_ctrl &= ~LCD_BLINKON;
   338:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   339: }
   340: #endif
   341: 
   342: // -------------------------------------------------------------------------
   343: #ifdef LCDBLINK
   344: void
   345: lcd_blink() {
   346:   LCD_ctrl |= LCD_BLINKON;
   347:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   348: }
   349: #endif
   350: 
   351: // -------------------------------------------------------------------------
   352: /** These commands scroll the display without changing the RAM */
   353: #ifdef LCDSCROLLDISPLAYLEFT
   354: void
   355: lcd_scroll_print_left(void) {
   356:   lcd_command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
   357: }
   358: #endif
   359: 
   360: // -------------------------------------------------------------------------
   361: #ifdef LCDSCROLLDISPLAYRIGHT
   362: void
   363: lcd_scroll_print_right(void) {
   364:   lcd_command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
   365: }
   366: #endif
   367: 
   368: // -------------------------------------------------------------------------
   369: /** This is for text that flows Left to Right */
   370: #ifdef LCDLEFTTORIGHT
   371: void
   372: lcd_left_to_right(void) {
   373:   LCD_mode |= LCD_ENTRYLEFT;
   374:   lcd_command(LCD_ENTRYMODESET | LCD_mode);
   375: }
   376: #endif
   377: 
   378: // -------------------------------------------------------------------------
   379: /** This is for text that flows Right to Left */
   380: #ifdef LCDRIGHTTOLEFT
   381: void
   382: lcd_right_to_left(void) {
   383:   LCD_mode &= ~LCD_ENTRYLEFT;
   384:   lcd_command(LCD_ENTRYMODESET | LCD_mode);
   385: }
   386: #endif
   387: 
   388: // -------------------------------------------------------------------------
   389: /** This will 'right justify' text from the cursor */
   390: #ifdef LCDAUTOSCROLL
   391: void
   392: lcd_autoscroll(void) {
   393:   LCD_mode |= LCD_ENTRYSHIFTINCREMENT;
   394:   lcd_command(LCD_ENTRYMODESET | LCD_mode);
   395: }
   396: #endif
   397: 
   398: // -------------------------------------------------------------------------
   399: /** This will 'left justify' text from the cursor */
   400: #ifndef LCDAUTOSCROLL
   401: void
   402: lcd_no_autoscroll(void) {
   403:   LCD_mode &= ~LCD_ENTRYSHIFTINCREMENT;
   404:   lcd_command(LCD_ENTRYMODESET | LCD_mode);
   405: }
   406: #endif
   407: 
   408: // -------------------------------------------------------------------------
   409: /** Initial Display settings! */
   410: void
   411: lcd_begin(uint8_t lines, uint8_t dotsize) {
   412:   if(lines > 1)
   413:     LCD_function |= LCD_2LINE;
   414: 
   415: #ifdef LCDSETCURSOR
   416:   LCD_lines = lines;
   417: #endif
   418: 
   419:   /* Some one line displays can select 10 pixel high font */
   420:   if((dotsize != 0) && (lines == 1))
   421:     LCD_function |= LCD_5x10DOTS;
   422: 
   423:   delay_ms(15); // Wait more than 15 ms after VDD rises to 4.5V
   424: 
   425:   /* Now we pull both RS and R/W low to begin commands */
   426:   RS_LOW();
   427:   EN_LOW();
   428: 
   429:   /* put the LCD into 4 bit mode */
   430:   if(!(LCD_function & LCD_8BITMODE)) {
   431:     /* this is according to the hitachi HD44780 datasheet p46, figure 24 */
   432: 
   433:     /* we start in 8bit mode, try to set 4 bit mode */
   434:     lcd_write4bits(0x03);
   435:     delay_ms(5); // Wait for more than 4.1 ms
   436:     /* second try */
   437:     lcd_write4bits(0x03);
   438:     delay_us(150); // Wait more than 100 μs
   439:     /* third go! */
   440:     lcd_write4bits(0x03);
   441:     delay_us(150); // Wait more than 100 μs
   442:     /* finally, set to 8-bit interface */
   443:     lcd_write4bits(0x02);
   444:   }
   445:   /* put the LCD into 8 bit mode */
   446:   else {
   447:     /* this is according to the hitachi HD44780 datasheet p45, figure 23 */
   448: 
   449:     /* Send function set command sequence */
   450:     lcd_command(LCD_FUNCTIONSET | LCD_function);
   451:     delay_ms(5); // Wait for more than 4.1 ms
   452: 
   453:     /* second try */
   454:     lcd_command(LCD_FUNCTIONSET | LCD_function);
   455:     delay_ms(5); // Wait for more than 4.1 ms
   456:     // delay_us(150);
   457: 
   458:     /* third go */
   459:     lcd_command(LCD_FUNCTIONSET | LCD_function);
   460:   }
   461: 
   462:   /* finally, set # lines, font size, etc. */
   463:   lcd_command(LCD_FUNCTIONSET | LCD_function);
   464: 
   465:   /* turn the display on with no cursor or blinking default */
   466:   LCD_ctrl = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
   467:   lcd_command(LCD_DISPLAYCONTROL | LCD_ctrl);
   468: 
   469:   /* clear it off */
   470:   lcd_command(LCD_CLEARDISPLAY); // clear display, set cursor position to zero
   471:   delay_ms(2);
   472: 
   473:   /* Initialize to default text direction (for romance languages) */
   474:   LCD_mode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
   475:   /* set the entry mode */
   476:   lcd_command(LCD_ENTRYMODESET | LCD_mode);
   477: }
   478: 
   479: // -------------------------------------------------------------------------
   480: /** Init LCD
   481:  * @param flags one of LCD_8BITMODE|LCD_4BITMODE, LCD_2LINE|LCD_1LINE, LCD_5x10DOTS|LCD_5x8DOTS
   482:  */
   483: void
   484: lcd_init(char fourbitmode) {
   485: 
   486:   LCD_ctrl = 0;
   487:   LCD_function = (fourbitmode ? LCD_4BITMODE : LCD_8BITMODE);
   488: #ifdef LCDSETCURSOR
   489:   LCD_lines = 0;
   490: #endif
   491:   LCD_mode = 0;
   492: 
   493:   RS_TRIS();
   494:   RS_LOW();
   495: #if defined(RW_TRIS) && defined(RW_PIN)
   496:   RW_TRIS();
   497:   RW_LOW();
   498: #endif
   499:   EN_TRIS();
   500:   EN_LOW();
   501: 
   502:   DATA_TRIS();
   503: 
   504: #if 0 // defined(DATA4_TRIS) && defined(DATA5_TRIS) && defined(DATA6_TRIS) && defined(DATA7_TRIS)
   505:   if((LCD_function & LCD_8BITMODE)) {
   506:     DATA4_TRIS = DATABUS_INIT; // DATA4_PIN = LOW;
   507:     DATA5_TRIS = DATABUS_INIT; // DATA5_PIN = LOW;
   508:     DATA6_TRIS = DATABUS_INIT; // DATA6_PIN = LOW;
   509:     DATA7_TRIS = DATABUS_INIT; // DATA7_PIN = LOW;
   510:   }
   511: #endif
   512: }
   513: 
   514: #endif // USE_HD44780_LCD
