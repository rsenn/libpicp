     1: /*
     2:  * Distributed by www.microchipC.com - one of the web's largest
     3:  * repositories of C source code for Microchip PIC micros.
     4:  *
     5:  * softser.c
     6:  *
     7:  * Interrupt Driven Serial Routines with Circular FIFO
     8:  * Copyright (c) 2006, Regulus Berdin
     9:  * All rights reserved.
    10:  *
    11:  * Permission is hereby granted, free of charge, to any person
    12:  * obtaining a copy of this software and associated documentation
    13:  * files (the "Software"), to deal in the Software without
    14:  * restriction, including without limitation the rights to use,
    15:  * copy, modify, merge, publish, distribute, sublicense, and/or
    16:  * sell copies of the Software, and to permit persons to whom the
    17:  * Software is furnished to do so, subject to the following
    18:  * conditions:
    19:  *
    20:  * The above copyright notice and this permission notice shall be
    21:  * included in all copies or substantial portions of the Software.
    22:  *
    23:  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    24:  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    25:  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    26:  * NONINFRINGEMENT.  IN NO EVENT SHALL REGULUS BERDIN BE LIABLE FOR
    27:  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
    28:  * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    29:  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    30:  * SOFTWARE.
    31:  *
    32:  */
    33: 
    34: #define _SOFTSER_C_
    35: #include "softser.h"
    36: #include "const.h"
    37: #include "timer.h"
    38: 
    39: #ifdef USE_SOFTSER
    40: 
    41: // this function receives a single serial byte from the PC
    42: // the function main must first detect the start bit, then
    43: // call receive_serial_byte()
    44: 
    45: uint8_t softser_rdata; // holds the serial byte that was received
    46: 
    47: void
    48: softser_init(void) {
    49:   // T0CS = 0;
    50:   // PSA = 0;
    51:   //  PS0 = 0; PS1 = 0; PS2 = 0; // prescaler 1:2
    52:   //  PS0 = 0;  PS1 = 1; PS2 = 0; // prescaler 1:4
    53:   // T0PS = SOFTSER_PS;
    54: 
    55: #if SOFTSER_TIMER == 0
    56:   timer0_init(SOFTSER_PS);
    57: #elif SOFTSER_TIMER == 1
    58:   timer1_init(SOFTSER_PS);
    59: #elif SOFTSER_TIMER == 2
    60:   timer2_init(SOFTSER_PS);
    61: #else
    62: #pragma warning No timer setup for soft serial !
    63: #endif
    64: 
    65:   SOFTSER_IN_TRIS = INPUT;
    66:   SOFTSER_OUT_TRIS = OUTPUT;
    67:   SOFTSER_OUTB(LOW);
    68: }
    69: 
    70: // returns 1 when start bit received or 0 when timeout
    71: //---------------------------------------------------------
    72: BOOL
    73: softser_poll(uint8_t bauds) {
    74:   int i = bauds;
    75: 
    76:   while(i--) {
    77:     // SOFTSER_TMR -= SOFTSER_BRG;            // load corrected baud value
    78: 
    79:     SOFTSER_TMR = (256 - SOFTSER_BRG);
    80:     while(SOFTSER_TMR & (1 << 7)) {
    81:       if(SOFTSER_INB())
    82:         return 1;
    83:     }
    84:   }
    85:   return 0;
    86: }
    87: 
    88: //---------------------------------------------------------
    89: void
    90: softser_recv(void) {
    91:   // this manually receives a serial byte in any PIC pin.
    92:   // NOTE! serial is inverted to connect direct to PC serial port.
    93:   // baud timing is done by using SOFTSER_TMR and removing
    94:   // timer error after each baud. Starts with 1.5 baud delay,
    95:   // so each bit is sampled in middle of baud.
    96:   uint8_t i;
    97: 
    98:   i = 8; // 8 data bits to receive
    99: 
   100:   SOFTSER_TMR = 256 - SOFTSER_BRG - ((SOFTSER_BRG >> 1) - 1); // load TMR value for ~1.5 baud
   101:   while(SOFTSER_TMR & (1 << 7))
   102:     ; // wait for baud
   103: 
   104:   while(i) {                              // receive 8 serial bits, LSB first
   105:     softser_rdata = (softser_rdata >> 1); // rotate right to store each bit
   106:     if(SOFTSER_INB())
   107:       softser_rdata &= ~(1 << 7); // invert and save data bit
   108:     else
   109:       softser_rdata |= (1 << 7);
   110:     i--;
   111: 
   112:     SOFTSER_TMR -= SOFTSER_BRG; // load corrected baud value
   113:     while(SOFTSER_TMR & (1 << 7))
   114:       ; // wait for baud
   115:   }
   116: 
   117:   SOFTSER_TMR -= SOFTSER_BRG; // wait for stop bit, ensure serial port is free
   118:   while(SOFTSER_TMR & (1 << 7))
   119:     ;
   120: }
   121: 
   122: //---------------------------------------------------------
   123: uint8_t
   124: softser_getch(void) {
   125:   softser_rdata = 0;
   126:   softser_recv();
   127:   return softser_rdata;
   128: }
   129: 
   130: //---------------------------------------------------------
   131: void
   132: softser_putch(uint8_t data) {
   133:   // this manually sends a serial byte out any PIC pin.
   134:   // NOTE! serial is inverted to connect direct to PC serial port.
   135:   // baud timing is done by using SOFTSER_TMR and removing
   136:   // timer error after each baud.
   137:   uint8_t i;
   138: 
   139:   i = 8; // 8 data bits to send
   140: 
   141:   SOFTSER_OUTB(HIGH);                // make start bit
   142:   SOFTSER_TMR = (256 - SOFTSER_BRG); // load TMR value for first baud;
   143:   while(SOFTSER_TMR & (1 << 7))
   144:     ; // wait for baud
   145: 
   146:   while(i) { // send 8 serial bits, LSB first
   147:     if(data & 0x01)
   148:       SOFTSER_OUTB(LOW); // invert and send data bit
   149:     else
   150:       SOFTSER_OUTB(HIGH);
   151: 
   152:     data = (data >> 1); // rotate right to get next bit
   153:     i--;
   154:     SOFTSER_TMR -= SOFTSER_BRG; // load corrected baud value
   155:     while(SOFTSER_TMR & (1 << 7))
   156:       ; // wait for baud
   157:   }
   158: 
   159:   SOFTSER_OUTB(LOW);          // make stop bit
   160:   SOFTSER_TMR -= SOFTSER_BRG; // wait a couple of baud for safety
   161:   while(SOFTSER_TMR & (1 << 7))
   162:     ;
   163: 
   164:   SOFTSER_TMR -= SOFTSER_BRG;
   165:   while(SOFTSER_TMR & (1 << 7))
   166:     ;
   167: }
   168: 
   169: void
   170: softser_puts(const char* s) {
   171:   while(*s) softser_putch(*s++);
   172: }
   173: 
   174: void
   175: softser_puts2(uint8_t* s) {
   176:   while(*s) softser_putch(*s++);
   177: }
   178: 
   179: void
   180: softser_puthex(uint8_t v) {
   181:   uint8_t c;
   182: 
   183:   c = v >> 4;
   184:   if(c > 9) {
   185:     softser_putch('A' - 10 + c);
   186:   } else {
   187:     softser_putch('0' + c);
   188:   }
   189: 
   190:   c = v & 0x0F;
   191:   if(c > 9) {
   192:     softser_putch('A' - 10 + c);
   193:   } else {
   194:     softser_putch('0' + c);
   195:   }
   196: }
   197: 
   198: #endif
