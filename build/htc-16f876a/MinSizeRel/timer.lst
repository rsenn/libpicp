     1: #include "timer.h"
     2: 
     3: #ifdef PIC18F2550
     4: #define PIC18 1
     5: #endif
     6: #ifdef __18f14k50
     7: #define PIC18 1
     8: #endif
     9: #ifdef __18f25k50
    10: #define PIC18 1
    11: #endif
    12: #ifdef __18f2550
    13: #define PIC18 1
    14: #ifndef SDCC
    15: extern volatile unsigned char T0CON @0xFD5;
    16: #endif
    17: #endif
    18: 
    19: #ifndef PIC18
    20: #define T0CON OPTION_REG
    21: #endif
    22: 
    23: /* ----------------------- Timer 0 ----------------------- */
    24: #if USE_TIMER0
    25: 
    26: void
    27: timer0_init(uint8_t ps_mode) {
    28:   uint8_t prescaler = ps_mode & PRESCALE_MASK;
    29: 
    30:   TIMER0_VALUE = 0;
    31: 
    32:   // 0: Internal instruction cycle clock (CLKO) or 1: Transition on T0CKI pin
    33:   T0CON |= (!!(ps_mode & TIMER0_FLAGS_EXTCLK)) ? 0x20 : 0x00;
    34: 
    35:   // T0CKI pin: Increment on 1->0 or on 0->1 transition
    36:   T0CON |= (!!(ps_mode & EDGE_HIGH_LOW)) ? 0x10 : 0x00;
    37: 
    38: #ifdef PIC18
    39:   T0CON |= (!!(ps_mode & TIMER0_FLAGS_8BIT)) ? 0x40 : 0x00;
    40: #endif
    41: 
    42:   // If a prescaler is to be assigned to the Timer0 module
    43:   T0CON &= (!!prescaler) ? ~0x08 : ~0x00;
    44: 
    45:   T0CON &= ~0b111;
    46: 
    47:   if(prescaler > 0) {
    48:     T0CON |= (prescaler - 1) & 0b111;
    49:     //#if TIMER0_PRESCALER != 0
    50:     /*  --prescaler;
    51:       PS0 = prescaler&1;   prescaler >>= 1;
    52:       PS1 = prescaler&1;   prescaler >>= 1;
    53:       PS2 = prescaler&1; */
    54:   }
    55:   //  T0PS = prescaler - 1;
    56:   //#endif
    57: 
    58:   INTCON &= ~0x40; // TMR0IF = 0;
    59:   INTCON |= (!!(ps_mode & TIMER0_FLAGS_INTR)) ? 0x20 : 0x00;
    60: }
    61: 
    62: unsigned short
    63: timer0_read_ps(void) {
    64:   uint8_t prev = TMR0;
    65:   uint16_t count = 0;
    66: 
    67:   T0CON |= 0x20; // T0CS = 1;
    68: 
    69:   do {
    70:     /* self-clocking */
    71:     T0CON |= 0x10; // T0SE = 1;
    72: 
    73:     NOP();
    74:     NOP();
    75: 
    76:     T0CON &= ~0x10; // T0SE = 0;
    77: 
    78:     NOP();
    79:     NOP();
    80: 
    81:     ++count;
    82: 
    83:     // count until TMR0 incremented
    84:   } while(prev == TMR0 && count <= 255);
    85: 
    86:   count = ((prev << 8) + (256 - count));
    87:   return count;
    88: }
    89: 
    90: #endif // USE_TIMER0
    91: 
    92: /* ----------------------- Timer 1 ----------------------- */
    93: #if USE_TIMER1
    94: 
    95: void
    96: timer1_init(uint8_t ps_mode) {
    97: 
    98:   T1CON &= ~0b00111110;
    99: 
   100:   T1CON |= (ps_mode & PRESCALE_MASK) << 4;
   101: 
   102:   T1CON |= (!!(ps_mode & TIMER1_FLAGS_EXTCLK)) << 1; // Internal clock source
   103: 
   104:   if(T1CON & 0b00000010) {
   105: #if defined(__12f1840) || defined(__16f628a)
   106:     T1CON |= (!(ps_mode & TIMER1_FLAGS_SYNC)) << 2;
   107: #else
   108:     T1CON |= (!(ps_mode & TIMER1_FLAGS_SYNC)) << 2;
   109: #endif
   110:   }
   111: 
   112:   TMR1H = 0;
   113:   TMR1L = 0;
   114: 
   115:   T1CON |= 0b1; // TMR1ON = 1;
   116: 
   117:   PIR1 &= ~0b1; //  TMR1IF = 0;
   118: 
   119:   PIE1 &= ~0b1;
   120:   PIE1 |= !!(ps_mode & TIMER1_FLAGS_INTR);
   121: }
   122: 
   123: #endif // USE_TIMER1
   124: 
   125: /* ----------------------- Timer 2 ----------------------- */
   126: #if USE_TIMER2
   127: 
   128: void
   129: timer2_init(uint8_t ps_mode) {
   130:   uint8_t ps = ps_mode & PRESCALE_MASK;
   131:   uint8_t postscaler = TIMER2_POSTSCALER;
   132: 
   133:   // Set timer 2 postscaler
   134:   T2CON &= ~0b01111111;
   135: 
   136:   T2CON |= (postscaler & 0b1111) << 3;
   137:   T2CON |= (ps & 0b11); // Set timer 2 prescaler to 1:1.
   138: 
   139:   TIMER2_VALUE = 0;
   140: 
   141:   T2CON |= 0b100; // TMR2ON = 1; // Enable timer 2.
   142: 
   143:   // TMR2IF = 0;
   144:   PIR1 &= ~0b10;
   145:   PIE1 = (!!(ps_mode & TIMER2_FLAGS_INTR)) << 1;
   146: }
   147: #endif // USE_TIMER2
